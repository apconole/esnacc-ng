/*
 * c_examples/simple/minbuf_ex.c - an example of how to call C ASN.1-BER
 *               encoders and decoders generated by snacc
 *               using the MinBuf buffer.
 *
 * AUTHOR: Mike Sample
 * DATE:   Mar 92
 *
 * $Header: /baseline/SNACC/c-examples/simple/minbuf-ex.c,v 1.2 2003/12/17 19:05:03 gronej Exp $
 * $Log: minbuf-ex.c,v $
 * Revision 1.2  2003/12/17 19:05:03  gronej
 * SNACC baseline merged with PER v1_7 tag
 *
 * Revision 1.1.2.1  2003/11/05 14:58:57  gronej
 * working PER code merged with esnacc_1_6
 *
 * Revision 1.1.1.1  2000/08/21 20:36:07  leonberp
 * First CVS Version of SNACC.
 *
 * Revision 1.5  1995/07/24  20:46:59  rj
 * changed `_' to `-' in file names.
 *
 * Revision 1.4  1995/02/18  15:12:55  rj
 * cosmetic changes
 *
 * Revision 1.3  1994/09/01  01:02:38  rj
 * more portable .h file inclusion.
 *
 * Revision 1.2  1994/08/31  08:59:36  rj
 * first check-in. for a list of changes to the snacc-1.1 distribution please refer to the ChangeLog.
 *
 */

#include "snacc.h"
#include "asn-incl.h"

#include <sys/file.h>
#include <sys/stat.h>
#if HAVE_FCNTL_H 
#include <fcntl.h>
#endif
#include <stdio.h>
#include <unistd.h>

#include "p-rec.h"
#include "min-buf.h"

int
main PARAMS ((argc, argv),
    int argc _AND_
    char *argv[])
{
    int fd;
    GenBuf buf, encBuf;
    char *encData;
    int encBufSize;
    AsnLen decodedLen;
    int     val;
    PersonnelRecord pr;
    PDU1 p;
    int      size;
    int i;
    char    *origData;
    struct stat sbuf;
    jmp_buf env;
    int  decodeErr;
    char *filename;
    char expected_pdu_bytes[] = { 0x30, /* SEQUENCE */
                                    0x06, /* LENGTH (6-bytes, def) */
                                      0x02, 0x01, 0x12, /*INT - 18*/
                                      0x02, 0x01, 0x30  /*INT - 48*/};

    if (argc != 2) {
        filename = "pr.ber";
    } else {
        filename = argv[1];
    }

    fd = open(filename, O_RDONLY, 0);
    if (fd < 0) {
        fprintf(stderr, "Usage: %s <BER data file name>\n", argv[0]);
        fprintf(stderr, "   Decodes the given PersonnelRecord BER data "
                "file\n");
        fprintf(stderr, "   and re-encodes it to stdout\n");
        exit(1);
    }

    if (fstat(fd, &sbuf) < 0) {
        perror("main: fstat");
        exit(1);
    }

    size = sbuf.st_size;
    origData = (char*)malloc(size);
    if (read(fd, origData, size) != size) {
        perror("main: read");
        exit(1);
    }

    close(fd);

    /* set up min buf  */
    GenBufFromMinBuf(&buf, origData);

    decodedLen = 0;
    decodeErr = FALSE;
    if ((val = setjmp(env)) == 0) {
        BDecPersonnelRecord(&buf, &pr, &decodedLen, env);
    } else {
        decodeErr = TRUE;
        fprintf(stderr, "ERROR - Decode routines returned %d\n", val);
    }

    if (decodeErr)
        exit(1);

    fprintf(stderr, "decodedValue PersonnelRecord ::= ");
    PrintPersonnelRecord(stderr, &pr, 0);
    fprintf(stderr, "\n\n");

    /*
     * setup a new buffer set up for writing.
     * make sure size is big enough to hold the encoded
     * value (may be larger than decoded value if encoding
     * with indef lengths - so add 512 slush bytes)
     */
    encBufSize = size + 512;
    encData = (char*) malloc(encBufSize);
    memset(encData, 0, encBufSize);

    /*
     * set 'buffer' up for writing by setting ptr
     * byte after last byte of the block
     */
    p.height = 18;
    p.width = 48;
    GenBufFromMinBuf(&encBuf, encData + encBufSize);
    decodedLen = BEncPDU1(&encBuf, &p);

    size = 0;
    for (i = encBufSize - decodedLen; i < encBufSize; i++, size++) {
        if (encData[i] != expected_pdu_bytes[size]) {
            printf("enc cmp failed - byte: %d [0x%02x vs 0x%02x]\n",
                   i, encData[i], expected_pdu_bytes[size]);
            exit(-1);
        }
    }

    free(encData);
    free(origData);
    return 0;
}










